/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vital.api.resources.labtests;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.vital.api.core.ApiError;
import com.vital.api.core.ClientOptions;
import com.vital.api.core.MediaTypes;
import com.vital.api.core.ObjectMappers;
import com.vital.api.core.QueryStringMapper;
import com.vital.api.core.RequestOptions;
import com.vital.api.core.ResponseBodyInputStream;
import com.vital.api.core.VitalException;
import com.vital.api.core.VitalHttpResponse;
import com.vital.api.errors.NotFoundError;
import com.vital.api.errors.UnprocessableEntityError;
import com.vital.api.resources.labtests.requests.ApiApiV1EndpointsVitalApiLabTestingOrdersHelpersAppointmentCancelRequest;
import com.vital.api.resources.labtests.requests.CreateLabTestRequest;
import com.vital.api.resources.labtests.requests.CreateOrderRequestCompatible;
import com.vital.api.resources.labtests.requests.ImportOrderBody;
import com.vital.api.resources.labtests.requests.LabTestsGetAreaInfoRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetByIdRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetLabelsPdfRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetMarkersByLabAndProviderIdRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetMarkersForLabTestRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetMarkersForOrderSetRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetMarkersRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetOrderPscInfoRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetOrdersRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetPaginatedRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetPhlebotomyAppointmentAvailabilityRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetPscAppointmentAvailabilityRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetPscInfoRequest;
import com.vital.api.resources.labtests.requests.LabTestsGetRequest;
import com.vital.api.resources.labtests.requests.LabTestsSimulateOrderProcessRequest;
import com.vital.api.resources.labtests.requests.RequestAppointmentRequest;
import com.vital.api.resources.labtests.requests.UpdateLabTestRequest;
import com.vital.api.resources.labtests.requests.ValidateIcdCodesBody;
import com.vital.api.resources.labtests.requests.VitalCoreClientsLabTestGetlabsSchemaAppointmentCancelRequest;
import com.vital.api.types.AppointmentAvailabilitySlots;
import com.vital.api.types.AppointmentBookingRequest;
import com.vital.api.types.AppointmentRescheduleRequest;
import com.vital.api.types.AreaInfo;
import com.vital.api.types.ClientFacingAppointment;
import com.vital.api.types.ClientFacingAppointmentCancellationReason;
import com.vital.api.types.ClientFacingLab;
import com.vital.api.types.ClientFacingLabTest;
import com.vital.api.types.ClientFacingMarker;
import com.vital.api.types.ClientFacingOrder;
import com.vital.api.types.GetMarkersResponse;
import com.vital.api.types.GetOrdersResponse;
import com.vital.api.types.HttpValidationError;
import com.vital.api.types.LabResultsMetadata;
import com.vital.api.types.LabResultsRaw;
import com.vital.api.types.LabTestResourcesResponse;
import com.vital.api.types.NotFoundErrorBody;
import com.vital.api.types.PostOrderResponse;
import com.vital.api.types.PscInfo;
import com.vital.api.types.ValidateIcdCodesResponse;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawLabTestsClient {
    protected final ClientOptions clientOptions;

    public AsyncRawLabTestsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * GET all the lab tests the team has access to.
     */
    public CompletableFuture<VitalHttpResponse<List<ClientFacingLabTest>>> get() {
        return get(LabTestsGetRequest.builder().build());
    }

    /**
     * GET all the lab tests the team has access to.
     */
    public CompletableFuture<VitalHttpResponse<List<ClientFacingLabTest>>> get(LabTestsGetRequest request) {
        return get(request, null);
    }

    /**
     * GET all the lab tests the team has access to.
     */
    public CompletableFuture<VitalHttpResponse<List<ClientFacingLabTest>>> get(
            LabTestsGetRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests");
        if (request.getGenerationMethod().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "generation_method", request.getGenerationMethod().get(), false);
        }
        if (request.getLabSlug().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_slug", request.getLabSlug().get(), false);
        }
        if (request.getCollectionMethod().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "collection_method", request.getCollectionMethod().get(), false);
        }
        if (request.getStatus().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "status", request.getStatus().get(), false);
        }
        if (request.getName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "name", request.getName().get(), false);
        }
        if (request.getOrderKey().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_key", request.getOrderKey().get(), false);
        }
        if (request.getOrderDirection().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_direction", request.getOrderDirection().get(), false);
        }
        if (request.getMarkerIds().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "marker_ids", request.getMarkerIds().get(), true);
        }
        if (request.getProviderIds().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "provider_ids", request.getProviderIds().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<List<ClientFacingLabTest>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), new TypeReference<List<ClientFacingLabTest>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> create(CreateLabTestRequest request) {
        return create(request, null);
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> create(
            CreateLabTestRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ClientFacingLabTest.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET all the lab tests the team has access to.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> getById(String labTestId) {
        return getById(labTestId, LabTestsGetByIdRequest.builder().build());
    }

    /**
     * GET all the lab tests the team has access to.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> getById(
            String labTestId, LabTestsGetByIdRequest request) {
        return getById(labTestId, request, null);
    }

    /**
     * GET all the lab tests the team has access to.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> getById(
            String labTestId, LabTestsGetByIdRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests")
                .addPathSegment(labTestId);
        if (request.getLabAccountId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_account_id", request.getLabAccountId().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ClientFacingLabTest.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> updateLabTest(String labTestId) {
        return updateLabTest(labTestId, UpdateLabTestRequest.builder().build());
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> updateLabTest(
            String labTestId, UpdateLabTestRequest request) {
        return updateLabTest(labTestId, request, null);
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> updateLabTest(
            String labTestId, UpdateLabTestRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests")
                .addPathSegment(labTestId)
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingLabTest>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ClientFacingLabTest.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET all the markers for the given lab.
     */
    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkers() {
        return getMarkers(LabTestsGetMarkersRequest.builder().build());
    }

    /**
     * GET all the markers for the given lab.
     */
    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkers(LabTestsGetMarkersRequest request) {
        return getMarkers(request, null);
    }

    /**
     * GET all the markers for the given lab.
     */
    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkers(
            LabTestsGetMarkersRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests/markers");
        if (request.getName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "name", request.getName().get(), false);
        }
        if (request.getALaCarteEnabled().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "a_la_carte_enabled", request.getALaCarteEnabled().get(), false);
        }
        if (request.getLabAccountId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_account_id", request.getLabAccountId().get(), false);
        }
        if (request.getPage().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "page", request.getPage().get(), false);
        }
        if (request.getSize().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "size", request.getSize().get(), false);
        }
        if (request.getLabId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_id", request.getLabId().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<GetMarkersResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), GetMarkersResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkersForOrderSet(
            LabTestsGetMarkersForOrderSetRequest request) {
        return getMarkersForOrderSet(request, null);
    }

    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkersForOrderSet(
            LabTestsGetMarkersForOrderSetRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests/list_order_set_markers");
        if (request.getPage().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "page", request.getPage().get(), false);
        }
        if (request.getSize().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "size", request.getSize().get(), false);
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<GetMarkersResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), GetMarkersResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkersForLabTest(String labTestId) {
        return getMarkersForLabTest(
                labTestId, LabTestsGetMarkersForLabTestRequest.builder().build());
    }

    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkersForLabTest(
            String labTestId, LabTestsGetMarkersForLabTestRequest request) {
        return getMarkersForLabTest(labTestId, request, null);
    }

    public CompletableFuture<VitalHttpResponse<GetMarkersResponse>> getMarkersForLabTest(
            String labTestId, LabTestsGetMarkersForLabTestRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests")
                .addPathSegment(labTestId)
                .addPathSegments("markers");
        if (request.getLabAccountId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_account_id", request.getLabAccountId().get(), false);
        }
        if (request.getPage().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "page", request.getPage().get(), false);
        }
        if (request.getSize().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "size", request.getSize().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<GetMarkersResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), GetMarkersResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET a specific marker for the given lab and provider_id
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingMarker>> getMarkersByLabAndProviderId(
            String providerId, int labId) {
        return getMarkersByLabAndProviderId(
                providerId,
                labId,
                LabTestsGetMarkersByLabAndProviderIdRequest.builder().build());
    }

    /**
     * GET a specific marker for the given lab and provider_id
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingMarker>> getMarkersByLabAndProviderId(
            String providerId, int labId, LabTestsGetMarkersByLabAndProviderIdRequest request) {
        return getMarkersByLabAndProviderId(providerId, labId, request, null);
    }

    /**
     * GET a specific marker for the given lab and provider_id
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingMarker>> getMarkersByLabAndProviderId(
            String providerId,
            int labId,
            LabTestsGetMarkersByLabAndProviderIdRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests")
                .addPathSegment(Integer.toString(labId))
                .addPathSegments("markers")
                .addPathSegment(providerId);
        if (request.getLabAccountId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_account_id", request.getLabAccountId().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingMarker>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ClientFacingMarker.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET all the labs.
     */
    public CompletableFuture<VitalHttpResponse<List<ClientFacingLab>>> getLabs() {
        return getLabs(null);
    }

    /**
     * GET all the labs.
     */
    public CompletableFuture<VitalHttpResponse<List<ClientFacingLab>>> getLabs(RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_tests/labs")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<List<ClientFacingLab>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), new TypeReference<List<ClientFacingLab>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET lab tests the team has access to as a paginated list.
     */
    public CompletableFuture<VitalHttpResponse<LabTestResourcesResponse>> getPaginated() {
        return getPaginated(LabTestsGetPaginatedRequest.builder().build());
    }

    /**
     * GET lab tests the team has access to as a paginated list.
     */
    public CompletableFuture<VitalHttpResponse<LabTestResourcesResponse>> getPaginated(
            LabTestsGetPaginatedRequest request) {
        return getPaginated(request, null);
    }

    /**
     * GET lab tests the team has access to as a paginated list.
     */
    public CompletableFuture<VitalHttpResponse<LabTestResourcesResponse>> getPaginated(
            LabTestsGetPaginatedRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_test");
        if (request.getLabTestLimit().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_test_limit", request.getLabTestLimit().get(), false);
        }
        if (request.getNextCursor().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "next_cursor", request.getNextCursor().get(), false);
        }
        if (request.getGenerationMethod().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "generation_method", request.getGenerationMethod().get(), false);
        }
        if (request.getLabSlug().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_slug", request.getLabSlug().get(), false);
        }
        if (request.getCollectionMethod().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "collection_method", request.getCollectionMethod().get(), false);
        }
        if (request.getStatus().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "status", request.getStatus().get(), false);
        }
        if (request.getName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "name", request.getName().get(), false);
        }
        if (request.getOrderKey().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_key", request.getOrderKey().get(), false);
        }
        if (request.getOrderDirection().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_direction", request.getOrderDirection().get(), false);
        }
        if (request.getMarkerIds().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "marker_ids", request.getMarkerIds().get(), true);
        }
        if (request.getProviderIds().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "provider_ids", request.getProviderIds().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<LabTestResourcesResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), LabTestResourcesResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<InputStream>> getLabTestCollectionInstructionPdf(String labTestId) {
        return getLabTestCollectionInstructionPdf(labTestId, null);
    }

    public CompletableFuture<VitalHttpResponse<InputStream>> getLabTestCollectionInstructionPdf(
            String labTestId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/lab_test")
                .addPathSegment(labTestId)
                .addPathSegments("collection_instruction_pdf")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<InputStream>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try {
                    ResponseBody responseBody = response.body();
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(new ResponseBodyInputStream(response), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET many orders with filters.
     */
    public CompletableFuture<VitalHttpResponse<GetOrdersResponse>> getOrders() {
        return getOrders(LabTestsGetOrdersRequest.builder().build());
    }

    /**
     * GET many orders with filters.
     */
    public CompletableFuture<VitalHttpResponse<GetOrdersResponse>> getOrders(LabTestsGetOrdersRequest request) {
        return getOrders(request, null);
    }

    /**
     * GET many orders with filters.
     */
    public CompletableFuture<VitalHttpResponse<GetOrdersResponse>> getOrders(
            LabTestsGetOrdersRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/orders");
        if (request.getSearchInput().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "search_input", request.getSearchInput().get(), false);
        }
        if (request.getStartDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "start_date", request.getStartDate().get(), false);
        }
        if (request.getEndDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "end_date", request.getEndDate().get(), false);
        }
        if (request.getUpdatedStartDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "updated_start_date", request.getUpdatedStartDate().get(), false);
        }
        if (request.getUpdatedEndDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "updated_end_date", request.getUpdatedEndDate().get(), false);
        }
        if (request.getOrderKey().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_key", request.getOrderKey().get(), false);
        }
        if (request.getOrderDirection().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_direction", request.getOrderDirection().get(), false);
        }
        if (request.getIsCritical().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "is_critical", request.getIsCritical().get(), false);
        }
        if (request.getInterpretation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "interpretation", request.getInterpretation().get(), false);
        }
        if (request.getUserId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "user_id", request.getUserId().get(), false);
        }
        if (request.getPatientName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "patient_name", request.getPatientName().get(), false);
        }
        if (request.getShippingRecipientName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "shipping_recipient_name",
                    request.getShippingRecipientName().get(),
                    false);
        }
        if (request.getPage().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "page", request.getPage().get(), false);
        }
        if (request.getSize().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "size", request.getSize().get(), false);
        }
        if (request.getStatus().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "status", request.getStatus().get(), true);
        }
        if (request.getOrderType().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_type", request.getOrderType().get(), true);
        }
        if (request.getOrderActivationTypes().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "order_activation_types",
                    request.getOrderActivationTypes().get(),
                    true);
        }
        if (request.getOrderIds().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "order_ids", request.getOrderIds().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<GetOrdersResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), GetOrdersResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Return the available time slots to book an appointment with a phlebotomist
     * for the given address and order.
     */
    public CompletableFuture<VitalHttpResponse<AppointmentAvailabilitySlots>> getPhlebotomyAppointmentAvailability(
            LabTestsGetPhlebotomyAppointmentAvailabilityRequest request) {
        return getPhlebotomyAppointmentAvailability(request, null);
    }

    /**
     * Return the available time slots to book an appointment with a phlebotomist
     * for the given address and order.
     */
    public CompletableFuture<VitalHttpResponse<AppointmentAvailabilitySlots>> getPhlebotomyAppointmentAvailability(
            LabTestsGetPhlebotomyAppointmentAvailabilityRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order/phlebotomy/appointment/availability");
        if (request.getStartDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "start_date", request.getStartDate().get(), false);
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<AppointmentAvailabilitySlots>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), AppointmentAvailabilitySlots.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Book an at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> bookPhlebotomyAppointment(
            String orderId, AppointmentBookingRequest request) {
        return bookPhlebotomyAppointment(orderId, request, null);
    }

    /**
     * Book an at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> bookPhlebotomyAppointment(
            String orderId, AppointmentBookingRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("phlebotomy/appointment/book")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Request an at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> requestPhlebotomyAppointment(
            String orderId, RequestAppointmentRequest request) {
        return requestPhlebotomyAppointment(orderId, request, null);
    }

    /**
     * Request an at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> requestPhlebotomyAppointment(
            String orderId, RequestAppointmentRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("phlebotomy/appointment/request")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Reschedule a previously booked at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> reschedulePhlebotomyAppointment(
            String orderId, AppointmentRescheduleRequest request) {
        return reschedulePhlebotomyAppointment(orderId, request, null);
    }

    /**
     * Reschedule a previously booked at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> reschedulePhlebotomyAppointment(
            String orderId, AppointmentRescheduleRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("phlebotomy/appointment/reschedule")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Cancel a previously booked at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> cancelPhlebotomyAppointment(
            String orderId, ApiApiV1EndpointsVitalApiLabTestingOrdersHelpersAppointmentCancelRequest request) {
        return cancelPhlebotomyAppointment(orderId, request, null);
    }

    /**
     * Cancel a previously booked at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> cancelPhlebotomyAppointment(
            String orderId,
            ApiApiV1EndpointsVitalApiLabTestingOrdersHelpersAppointmentCancelRequest request,
            RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("phlebotomy/appointment/cancel")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get the list of reasons for cancelling an at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<List<ClientFacingAppointmentCancellationReason>>>
            getPhlebotomyAppointmentCancellationReason() {
        return getPhlebotomyAppointmentCancellationReason(null);
    }

    /**
     * Get the list of reasons for cancelling an at-home phlebotomy appointment.
     */
    public CompletableFuture<VitalHttpResponse<List<ClientFacingAppointmentCancellationReason>>>
            getPhlebotomyAppointmentCancellationReason(RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order/phlebotomy/appointment/cancellation-reasons")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<List<ClientFacingAppointmentCancellationReason>>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(),
                                        new TypeReference<List<ClientFacingAppointmentCancellationReason>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get the appointment associated with an order.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> getPhlebotomyAppointment(String orderId) {
        return getPhlebotomyAppointment(orderId, null);
    }

    /**
     * Get the appointment associated with an order.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> getPhlebotomyAppointment(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("phlebotomy/appointment")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET information about an area with respect to lab-testing.
     * <p>Information returned:</p>
     * <ul>
     * <li>Whether a given zip code is served by our Phlebotomy network.</li>
     * <li>List of Lab locations in the area.</li>
     * </ul>
     */
    public CompletableFuture<VitalHttpResponse<AreaInfo>> getAreaInfo(LabTestsGetAreaInfoRequest request) {
        return getAreaInfo(request, null);
    }

    /**
     * GET information about an area with respect to lab-testing.
     * <p>Information returned:</p>
     * <ul>
     * <li>Whether a given zip code is served by our Phlebotomy network.</li>
     * <li>List of Lab locations in the area.</li>
     * </ul>
     */
    public CompletableFuture<VitalHttpResponse<AreaInfo>> getAreaInfo(
            LabTestsGetAreaInfoRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order/area/info");
        QueryStringMapper.addQueryParameter(httpUrl, "zip_code", request.getZipCode(), false);
        if (request.getRadius().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "radius", request.getRadius().get(), false);
        }
        if (request.getLab().isPresent()) {
            QueryStringMapper.addQueryParameter(httpUrl, "lab", request.getLab().get(), false);
        }
        if (request.getLabAccountId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_account_id", request.getLabAccountId().get(), false);
        }
        if (request.getLabs().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "labs", request.getLabs().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<AreaInfo>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), AreaInfo.class), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<PscInfo>> getPscInfo(LabTestsGetPscInfoRequest request) {
        return getPscInfo(request, null);
    }

    public CompletableFuture<VitalHttpResponse<PscInfo>> getPscInfo(
            LabTestsGetPscInfoRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order/psc/info");
        QueryStringMapper.addQueryParameter(httpUrl, "zip_code", request.getZipCode(), false);
        QueryStringMapper.addQueryParameter(httpUrl, "lab_id", request.getLabId(), false);
        if (request.getRadius().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "radius", request.getRadius().get(), false);
        }
        if (request.getLabAccountId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lab_account_id", request.getLabAccountId().get(), false);
        }
        if (request.getCapabilities().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "capabilities", request.getCapabilities().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<PscInfo>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), PscInfo.class), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<PscInfo>> getOrderPscInfo(String orderId) {
        return getOrderPscInfo(orderId, LabTestsGetOrderPscInfoRequest.builder().build());
    }

    public CompletableFuture<VitalHttpResponse<PscInfo>> getOrderPscInfo(
            String orderId, LabTestsGetOrderPscInfoRequest request) {
        return getOrderPscInfo(orderId, request, null);
    }

    public CompletableFuture<VitalHttpResponse<PscInfo>> getOrderPscInfo(
            String orderId, LabTestsGetOrderPscInfoRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("psc/info");
        if (request.getRadius().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "radius", request.getRadius().get(), false);
        }
        if (request.getCapabilities().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "capabilities", request.getCapabilities().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<PscInfo>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), PscInfo.class), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * This endpoint returns the lab results for the order.
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getResultPdf(String orderId) {
        return getResultPdf(orderId, null);
    }

    /**
     * This endpoint returns the lab results for the order.
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getResultPdf(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("result/pdf")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<InputStream>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try {
                    ResponseBody responseBody = response.body();
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(new ResponseBodyInputStream(response), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Return metadata related to order results, such as lab metadata,
     * provider and sample dates.
     */
    public CompletableFuture<VitalHttpResponse<LabResultsMetadata>> getResultMetadata(String orderId) {
        return getResultMetadata(orderId, null);
    }

    /**
     * Return metadata related to order results, such as lab metadata,
     * provider and sample dates.
     */
    public CompletableFuture<VitalHttpResponse<LabResultsMetadata>> getResultMetadata(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("result/metadata")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<LabResultsMetadata>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), LabResultsMetadata.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Return both metadata and raw json test data
     */
    public CompletableFuture<VitalHttpResponse<LabResultsRaw>> getResultRaw(String orderId) {
        return getResultRaw(orderId, null);
    }

    /**
     * Return both metadata and raw json test data
     */
    public CompletableFuture<VitalHttpResponse<LabResultsRaw>> getResultRaw(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("result")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<LabResultsRaw>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), LabResultsRaw.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * This endpoint returns the printed labels for the order.
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getLabelsPdf(
            String orderId, LabTestsGetLabelsPdfRequest request) {
        return getLabelsPdf(orderId, request, null);
    }

    /**
     * This endpoint returns the printed labels for the order.
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getLabelsPdf(
            String orderId, LabTestsGetLabelsPdfRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("labels/pdf");
        if (request.getNumberOfLabels().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "number_of_labels", request.getNumberOfLabels().get(), false);
        }
        QueryStringMapper.addQueryParameter(httpUrl, "collection_date", request.getCollectionDate(), false);
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<InputStream>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try {
                    ResponseBody responseBody = response.body();
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(new ResponseBodyInputStream(response), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<AppointmentAvailabilitySlots>> getPscAppointmentAvailability(
            LabTestsGetPscAppointmentAvailabilityRequest request) {
        return getPscAppointmentAvailability(request, null);
    }

    public CompletableFuture<VitalHttpResponse<AppointmentAvailabilitySlots>> getPscAppointmentAvailability(
            LabTestsGetPscAppointmentAvailabilityRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order/psc/appointment/availability");
        QueryStringMapper.addQueryParameter(httpUrl, "lab", request.getLab(), false);
        if (request.getStartDate().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "start_date", request.getStartDate().get(), false);
        }
        if (request.getZipCode().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "zip_code", request.getZipCode().get(), false);
        }
        if (request.getRadius().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "radius", request.getRadius().get(), false);
        }
        if (request.getSiteCodes().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "site_codes", request.getSiteCodes().get(), true);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<AppointmentAvailabilitySlots>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), AppointmentAvailabilitySlots.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, NotFoundErrorBody.class),
                                        response));
                                return;
                            case 422:
                                future.completeExceptionally(new UnprocessableEntityError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, HttpValidationError.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> bookPscAppointment(
            String orderId, AppointmentBookingRequest request) {
        return bookPscAppointment(orderId, request, null);
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> bookPscAppointment(
            String orderId, AppointmentBookingRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("psc/appointment/book")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> reschedulePscAppointment(
            String orderId, AppointmentRescheduleRequest request) {
        return reschedulePscAppointment(orderId, request, null);
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> reschedulePscAppointment(
            String orderId, AppointmentRescheduleRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("psc/appointment/reschedule")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> cancelPscAppointment(
            String orderId, VitalCoreClientsLabTestGetlabsSchemaAppointmentCancelRequest request) {
        return cancelPscAppointment(orderId, request, null);
    }

    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> cancelPscAppointment(
            String orderId,
            VitalCoreClientsLabTestGetlabsSchemaAppointmentCancelRequest request,
            RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("psc/appointment/cancel")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<List<ClientFacingAppointmentCancellationReason>>>
            getPscAppointmentCancellationReason() {
        return getPscAppointmentCancellationReason(null);
    }

    public CompletableFuture<VitalHttpResponse<List<ClientFacingAppointmentCancellationReason>>>
            getPscAppointmentCancellationReason(RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order/psc/appointment/cancellation-reasons")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<List<ClientFacingAppointmentCancellationReason>>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(),
                                        new TypeReference<List<ClientFacingAppointmentCancellationReason>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get the appointment associated with an order.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> getPscAppointment(String orderId) {
        return getPscAppointment(orderId, null);
    }

    /**
     * Get the appointment associated with an order.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> getPscAppointment(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("psc/appointment")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingAppointment>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ClientFacingAppointment.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET collection instructions for an order
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getOrderCollectionInstructionPdf(String orderId) {
        return getOrderCollectionInstructionPdf(orderId, null);
    }

    /**
     * GET collection instructions for an order
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getOrderCollectionInstructionPdf(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("collection_instruction_pdf")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<InputStream>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try {
                    ResponseBody responseBody = response.body();
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(new ResponseBodyInputStream(response), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET requisition pdf for an order
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getOrderRequistionPdf(String orderId) {
        return getOrderRequistionPdf(orderId, null);
    }

    /**
     * GET requisition pdf for an order
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getOrderRequistionPdf(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("requisition/pdf")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<InputStream>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try {
                    ResponseBody responseBody = response.body();
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(new ResponseBodyInputStream(response), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET ABN pdf for an order
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getOrderAbnPdf(String orderId) {
        return getOrderAbnPdf(orderId, null);
    }

    /**
     * GET ABN pdf for an order
     */
    public CompletableFuture<VitalHttpResponse<InputStream>> getOrderAbnPdf(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("abn_pdf")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<InputStream>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try {
                    ResponseBody responseBody = response.body();
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(new ResponseBodyInputStream(response), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * GET individual order by ID.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingOrder>> getOrder(String orderId) {
        return getOrder(orderId, null);
    }

    /**
     * GET individual order by ID.
     */
    public CompletableFuture<VitalHttpResponse<ClientFacingOrder>> getOrder(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ClientFacingOrder>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ClientFacingOrder.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> createOrder(CreateOrderRequestCompatible request) {
        return createOrder(request, null);
    }

    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> createOrder(
            CreateOrderRequestCompatible request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .build();
        Map<String, Object> properties = new HashMap<>();
        properties.put("user_id", request.getUserId());
        if (request.getLabTestId().isPresent()) {
            properties.put("lab_test_id", request.getLabTestId());
        }
        if (request.getOrderSet().isPresent()) {
            properties.put("order_set", request.getOrderSet());
        }
        if (request.getCollectionMethod().isPresent()) {
            properties.put("collection_method", request.getCollectionMethod());
        }
        if (request.getPhysician().isPresent()) {
            properties.put("physician", request.getPhysician());
        }
        if (request.getHealthInsurance().isPresent()) {
            properties.put("health_insurance", request.getHealthInsurance());
        }
        if (request.getPriority().isPresent()) {
            properties.put("priority", request.getPriority());
        }
        if (request.getBillingType().isPresent()) {
            properties.put("billing_type", request.getBillingType());
        }
        if (request.getIcdCodes().isPresent()) {
            properties.put("icd_codes", request.getIcdCodes());
        }
        if (request.getConsents().isPresent()) {
            properties.put("consents", request.getConsents());
        }
        if (request.getActivateBy().isPresent()) {
            properties.put("activate_by", request.getActivateBy());
        }
        if (request.getAoeAnswers().isPresent()) {
            properties.put("aoe_answers", request.getAoeAnswers());
        }
        if (request.getPassthrough().isPresent()) {
            properties.put("passthrough", request.getPassthrough());
        }
        if (request.getLabAccountId().isPresent()) {
            properties.put("lab_account_id", request.getLabAccountId());
        }
        if (request.getCreatorMemberId().isPresent()) {
            properties.put("creator_member_id", request.getCreatorMemberId());
        }
        properties.put("patient_details", request.getPatientDetails());
        properties.put("patient_address", request.getPatientAddress());
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(properties), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "X-Idempotency-Key", request.getIdempotencyKey().get());
        }
        if (request.getIdempotencyError().isPresent()) {
            _requestBuilder.addHeader(
                    "X-Idempotency-Error", request.getIdempotencyError().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<PostOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), PostOrderResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> importOrder(ImportOrderBody request) {
        return importOrder(request, null);
    }

    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> importOrder(
            ImportOrderBody request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order/import")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<PostOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), PostOrderResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * POST cancel order
     */
    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> cancelOrder(String orderId) {
        return cancelOrder(orderId, null);
    }

    /**
     * POST cancel order
     */
    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> cancelOrder(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("cancel")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<PostOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), PostOrderResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get available test kits.
     */
    public CompletableFuture<VitalHttpResponse<Object>> simulateOrderProcess(String orderId) {
        return simulateOrderProcess(
                orderId, LabTestsSimulateOrderProcessRequest.builder().build());
    }

    /**
     * Get available test kits.
     */
    public CompletableFuture<VitalHttpResponse<Object>> simulateOrderProcess(
            String orderId, LabTestsSimulateOrderProcessRequest request) {
        return simulateOrderProcess(orderId, request, null);
    }

    /**
     * Get available test kits.
     */
    public CompletableFuture<VitalHttpResponse<Object>> simulateOrderProcess(
            String orderId, LabTestsSimulateOrderProcessRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("test");
        if (request.getFinalStatus().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "final_status", request.getFinalStatus().get(), false);
        }
        if (request.getDelay().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "delay", request.getDelay().get(), false);
        }
        RequestBody body;
        try {
            body = RequestBody.create("", null);
            if (request.getBody().isPresent()) {
                body = RequestBody.create(
                        ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<Object>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), Object.class), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * PATCH update on site collection order when draw is completed
     */
    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> updateOnSiteCollectionOrderDrawCompleted(
            String orderId) {
        return updateOnSiteCollectionOrderDrawCompleted(orderId, null);
    }

    /**
     * PATCH update on site collection order when draw is completed
     */
    public CompletableFuture<VitalHttpResponse<PostOrderResponse>> updateOnSiteCollectionOrderDrawCompleted(
            String orderId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/order")
                .addPathSegment(orderId)
                .addPathSegments("draw_completed")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<PostOrderResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), PostOrderResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<VitalHttpResponse<ValidateIcdCodesResponse>> validateIcdCodes(
            ValidateIcdCodesBody request) {
        return validateIcdCodes(request, null);
    }

    public CompletableFuture<VitalHttpResponse<ValidateIcdCodesResponse>> validateIcdCodes(
            ValidateIcdCodesBody request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v3/insurance/validate_icd_codes")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new VitalException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<VitalHttpResponse<ValidateIcdCodesResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new VitalHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), ValidateIcdCodesResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 422) {
                            future.completeExceptionally(new UnprocessableEntityError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, HttpValidationError.class),
                                    response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new ApiError(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new VitalException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
